#!/usr/bin/expect -f
#
# This script performs any available actions bound to the specified user, 
# by repeatedly querying the PEOS server for available actions, then 
# sending "run" and "done" commands for those actions.
#
# Invoke as follows:
# expect -f enact.exp host port user password


# This TCL procedure performs an action by sending a "run" followed by a "done"
# command.  It is called by the enact procedure.  (See the proc(n) man page 
# for a description of TCL procedures.)
proc run_action {process action} {
    send -- "run $process $action\r"
    expect  "100 *\r"

    sleep .1

    send -- "done $process $action\r"
    expect  "100 *\r"

    sleep .1
}


# This TCL procedure performs the first available action, if any.  It sends 
# the "available" command, then grabs the first line and extracts the process
# and action identifiers if present; these are passed to the run_action 
# procedure above.
proc enact {} {
    # Ask the kernel for available actions.
    send "available\r"

    # Wait for the reply.  If any actions are returned, the regular expression
    # will match the process id and action name of the first line as 
    # subexpressions, so they can be passed to the run_action procedure.
    expect  { 
	-re "100-(\[^ \]+)\[ \](\[^ \]+)\[ \].*\r\n100\[ \t\r\n]*$" {
	    # First parenthesized sub-expression match is in 
	    # expect_out(1,string) (see the expect(1) man page).  This
	    # is the process id.
	    set process $expect_out(1,string)

	    # The second parenthesized sub-expression match is in 
	    # expect_out(2,string);  this is the action name.
	    set action $expect_out(2,string)

	    # Now run the action.
	    run_action $process $action

	    # Signal an action was available with the return code.
	    return 1;
	}
	-re "100\[ \t\r\n\]*$" {
	    # No actions available; return 0 to signal this fact.
	    return 0;
	}
	-re "500\[ \t\r\n\]*$" {
	    # This is an error condition; exit the test.
	    puts stderr [format "Error executing 'available' command: %s" \
		    $expect_out(buffer)]
	    exit 1;
	}
    }
}

# Argument parsing.
if {$argc < 4} {
    puts "Usage: expect $argv0 host port user password"
    exit
}

set host [lindex $argv 0]
set port [lindex $argv 1]
set user [lindex $argv 2]
set password [lindex $argv 3]


# Connect to PEOS server via telnet.
set timeout -1
spawn telnet $host $port
match_max 100000
# Look for response from telnet indicating connection established.
expect  "Escape*\r"

# We are connected; send login command to PEOS and wait for reply.
send -- "login $user $password\r"
expect  "100 login successful\r"

# Login successful.  Now, loop asking for available actions, then performing
# one of them.

while {[enact] != 0} {
    puts "Action performed."
} 

puts "No more actions."

# Exit PEOS session.
send -- "exit\r"
expect  "Connection closed by foreign host.\r"

# Wait for end of file from telnet before ending expect session.
expect eof
