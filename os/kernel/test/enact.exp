#***********************
# File Name: Enact.exp
# Author: Scott Richard
# Created using expect scripts
#!/usr/bin/expect -f
#
# Description:
#   This script performs any available actions bound to the specified
#   user, by repeatedly querying the PEOS server for available actions,
#   then sending "run" and "done" commands for those actions.
#
#   This test harness is designed to test the "Happy Path" of the kernel.
#   The "Happy Path" is a series of commands that should execute.  This test
#   harness does not test any  e "Happy Path" is a series of commands that
#   should execute.  This test harness does not test any boundries, only
#   the path of defined commands.
#
#   If an error is encountered it is returned to the user. A PEOS
#   returned error begins with a 500.        Time out errors are also
#   returned if encountered.  Time out errors occur when the system is
#   asked to do something and goes away for more than 15 seconds.
#
# Invoke as follows:
#   expect -f enact.exp host port user password
#
# Example:
#	% expect -f enact.exp milton 14523 bsmith color23
#
#	where bsmith is the login name of Bob Smith, use your login name
#	and color23 is his password.  Currently any password works as long
#	as one is entered... ie: 3345, billy, xxxx, etc.  Something must be
#	entered for the password.
#
# Example Session with PEOS:
#
#	Telnet to milton
#	login 
#	password
#	change directory to where the enact.exp resides:
#		example: cd peos/src/os/kernel/test
#		file name:  enact.exp
#	envoke enact.exp as example above
#		%expect -f enact.exp milton 14523 bsmith color23
#
#    All avaliabe actions to PEOS Server will be performed by
#    querying the server for available actions and then sending "run" and
#    "done" commands for those actions. All possible actions will be
#    perfomed. If everything goes well the server will be given an "exit"
#    command and will shut down.  Other wise an error will be displayed.
#
#    Keep an eye on the original PEOS server screen.  It will also
#    display errors and problems that it comes across in executing the
#    commands of the enact script file.
#
#************************



#*****************************************************************
# Procedure Name: run_action
# Description: This TCL procedure performs an action by sending a
#     run" followed by a "done" command.  It is called by the enact
#     procedure.  (See the proc(n) man page for a description of TCL
#     procedures.)
# Parameters: process -- the model or process name 
#             action  -- the action associated with the model
#
# Procedure Algorithm:
#	run_action sends the "run" command with a model and
#       action. "100" followed by a carriage return is "expected" to be
#       returned if executed correctly.
#
#       delay of 1/10th of a second
#
#       send the "done" command with the model and action name
#       Expect a "100" with a carriage return to follow (if executed
#       correctly).
#
#  	delay of 1/10th of a second
#
# Errors: if error is encounted the function returns?? with no error code
#*****************************************************************
proc run_action {process action} {
    send -- "run $process $action\r"
    expect  "100 *\r"

    sleep .1

    send -- "done $process $action\r"
    expect  "100 *\r"

    sleep .1
}

#*****************************************************************
# Procedure Name: enact 
# Description: This TCL procedure performs the first available
#      action, if any.  It sends the "available" command, then grabs the
#      first line and extracts the process and action identifiers if
#      present; these are passed to the run_action procedure above.
# Procedure Parameters:  None
#
# Algorithm:
#	Request from kernel "available" actions by sending the command
#          "available" with a carriage return
#
#	Wait for the reply.  If any actions are returned, the regular
#	expression will match the process id and action name of the 
#       first line as subexpressions, so they can be passed to the run_action
#	procedure.
#
#	If there is an action available to be run, send it to the
#	run_action procedure. If not signal that no actions avialable.  If an
#	error is encountered return this to user:
# Return Codes:
#
#	(1)	Action available
#       (0) 	No action available
#
#
# Error Codes:
#	"Error executing "available"" is returned when a -500 is
#       encountered.
#
#	"Time out error" is returned when more than 15 seconds elapse
# 	awaiting for the kernel to respond.  This should only occur if the
#	kernel gets hung up.
#
#****************************************************************
 proc enact {} {
    # Ask the kernel for available actions.
    send "available\r"

    # Wait for the reply.  If any actions are returned, the regular
    # expression will match the process id and action name of the first
    # line as subexpressions, so they can be passed to the run_action 
    # procedure.
   
      expect  { 
	-re "100-(\[^ \]+)\[ \](\[^ \]+)\[ \].*\r\n100\[ \t\r\n]*$" {
	    # First parenthesized sub-expression match is in 
	    # expect_out(1,string) (see the expect(1) man page).  This
	    # is the process id.
	    set process $expect_out(1,string)

	    # The second parenthesized sub-expression match is in 
	    # expect_out(2,string);  this is the action name.
	    set action $expect_out(2,string)

	    # Now run the action.
	    run_action $process $action

	    # Signal an action was available with the return code.
	    return 1;
	}
	-re "100\[ \t\r\n\]*$" {
	    # No actions available; return 0 to signal this fact.
	    return 0;
	}
	-re "500\[ \t\r\n\]*$" {
	    # This is an error condition; exit the test.
	    puts stderr [format "Error executing 'available' command: %s" \
		    $expect_out(buffer)]
	    exit 1;
	}
	timeout {
	    # This is an error condition; exit the test.
	    puts stderr [format "Timeout executing 'available' command"]
	    exit 1;
	}
    }
}

#*********************************************************
# Main program
# Description:
#	The command line is parsed and the host, port, user, and password
#	are extracted. The telnet session is started utilizing the
#	provided port#.  The user is loged into the PEOS system using the
#	username and password.
#
#	The script then sends a "list" command and PEOS returns a list of
#	possible models to be created.  This list is stored and then
#	parsed for individual execution. 
#
#	Using a "for" loop and a "while" loop the list of models are
#	individualy run with all corisponding actions. Once all models and
#	actions executed the scipt exits PEOS and ends.  
#
# Errors:
#	"Error Processing List Command" -- encounter if "list" command
#		returns a "-500"
#
#**********************************************************************

# Argument parsing.
if {$argc < 4} {
    puts "Usage: expect $argv0 host port user password"
    exit
}

set host [lindex $argv 0]
set port [lindex $argv 1]
set user [lindex $argv 2]
set password [lindex $argv 3]


# Connect to PEOS server via telnet.
set timeout 15
spawn telnet $host $port
match_max 100000
# Look for response from telnet indicating connection established.
expect  "Escape*\r"

# We are connected; send login command to PEOS and wait for reply.
send -- "login $user $password\r"
expect  "100 login successful\r"

# Login successful; list compiled models by sending 'available' message.
send -- "list\r"

# Successful requests are acknowledged with "100" reply lines.  "500"
# indicates an error.  
set models {}
expect {
    "100\[ \t\r\n\]" {
	# Expect puts the output from the server into the TCL array element
	# expect_out(buffer).  We can use this to extract the actions into 
	# a TCL list.
	
	# Split the output by lines.
	set lines [split $expect_out(buffer) "\n"]

	# Grab the process and action from each line.
	set models {}
	foreach l $lines {
	    # Regexp compares a string to a regular expression, and optionally
	    # extracts subexpressions into variables.   The following looks 
	    # for a regular expression consisting of the string "100-",
	    # followed by a subexpression (the process name) consisting of 
	    # any characters except a space, followed by a space.
	    # (See regexp(n) man page.)
	    if {[regexp "100-(\[^ \n\r\t\]+)\[ \n\r\t\]" $l dummy process action]==1} {
		lappend models $process
	    }
	}
    }
    "500*\r" {
	puts stdout [format "Error processing list command: %s" $output(buffer)]
    }
}

foreach model $models {
    send "create $model\r"
    expect "100 create successful\r"
    
    # Now, loop asking for available actions, then performing one of them.
    while {[enact] != 0} {
	puts "Action performed."
    } 
}
puts "No more actions."

# Exit PEOS session.
send -- "exit\r"
expect  "Connection closed by foreign host.\r"

# Wait for end of file from telnet before ending expect session.
expect eof
