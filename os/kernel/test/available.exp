#!/usr/bin/expect -f
#

# This expect script prints a list of the available actions bound to 
# the user specified on the command line.
#
# Invoke as:
# expect -f available.exp host port user password

# Expect is a testing tool built using John Ousterhout's TCL scripting
# language.  The man page for expect (expect(1)) is a good reference
# to expect's features; I have not been able to find a good tutorial
# on expect, other than the O'Reilly book Exploring Expect.  The
# expect web site is http://expect.nist.gov/.  
#
# Since expect uses TCL, you will need to know something about this
# scripting language to understand these scripts.  A TCL tutorial can
# be found at:
# http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin.html.  A
# list of other TCL resources is at:
# http://www.sco.com/Technology/tcl/Tcl.html. Finally, man pages on
# all TCL commands can be found in section 'n' of the Linux manual:
# type 'man n command' to see the page about "command".

# Argument parsing.
if {$argc < 4} {
    puts "Usage: expect $argv0 host port user password" 
    exit
}

set host [lindex $argv 0]
set port [lindex $argv 1]
set user [lindex $argv 2]
set password [lindex $argv 3]


# Connect to PEOS server via telnet.
set timeout -1
spawn telnet $host $port
match_max 100000
# Look for response from telnet indicating connection established.
expect  "Escape*\r"

# We are connected; send login command to PEOS and wait for reply.
send -- "login $user $password\r"
expect  "100 login successful\r"

# Login successful; get available tasks by sending 'available' message.
send -- "available\r"

# Successful requests are acknowledged with "100" reply lines.  "500"
# indicates an error.  
expect {
    "100\[ \t\r\n\]" {
	# Expect puts the output from the server into the TCL array element
	# expect_out(buffer).  We can use this to extract the actions into 
	# a TCL list.
	
	# Split the output by lines.
	set lines [split $expect_out(buffer) "\n"]

	# Grab the process and action from each line.
	set actions {}
	foreach l $lines {
	    # Regexp compares a string to a regular expression, and optionally
	    # extracts subexpressions into variables.   The following looks 
	    # for a regular expression consisting of the string "100-",
	    # followed by a subexpression (the process name) consisting of 
	    # any characters except a space, followed by a space, followed by
	    # another subexpression (the action name) consisting of non-space
	    # characters, followed by the rest of the line.
	    
	    # (See regexp(n) man page.)
	    if {[regexp "100-(\[^ \]+)\[ \t\]+(\[^ \]+)\[ \].*" $l dummy process action]==1} {
		lappend actions [list $process $action]
	    }
	}
	
	# Now print out the list of actions.
	foreach act $actions {
	    set process [lindex $act 0]
	    set action [lindex $act 1]
	    puts stdout [format "Process: %s Action: %s" $process $action]
	}
    }
    "500*\r" {
	puts stdout [format "Error processing available command: %s" $output(buffer)]
    }
}

# Exit PEOS session.
send -- "exit\r"
expect  "Connection closed by foreign host.\r"

# Wait for end of file from telnet before ending expect session.
expect eof
