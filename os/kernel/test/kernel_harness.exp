#!/usr/bin/env expect

# Expect script to test kernel via shell.

proc parse_args {argv argc} {
    uplevel 1 {
	set i 0
	while {$i < $argc} {
	    set arg [lindex $argv $i]
	    switch -re -- $arg {
		^\[\-\]\[A-Za-z\]+ {
		    incr i
		    set [string trimleft $arg "-"] [lindex $argv $i]
		}
		default {
		    set tc_name $arg
		}
	    }
	    incr i
	}
    }
}

# Read test case definition.
proc read_tc {tc_name} {
    set input [open $tc_name "r"]

    while {![eof $input]} {
	set line [gets $input]
	set field [lindex $line 0]
	set data [lrange $line 1 end]
	switch -re $field {
	    "^\#.*$" {
		#puts stderr "A comment: $line"
		continue
	    }

	    script: {
		upvar script script
		set script [read $input]
	    }

	    default {
		set var [string trimright $field ":"]
		upvar $var $var
		set $var $data
	    }
	}
    }
}

proc trace {level msg} {
    global verbosity
    if {$verbosity >= $level} {
	puts stderr "$msg"
    }
}

proc error_msg {op act} {
    global expect_out
    puts -nonewline "FAILURE: while performing '$op' on '$act'"
    if [info exists expect_out(0,string)] {
	puts ": $expect_out(0,string)"
    } else {
	puts ""
    }
    exit
}

proc create_proc {model} {
    send "create $model\n"
    expect {
	-re "Created pid = \(\[0-9\]+\)" {
	    upvar pid pid
	    set pid $expect_out(1,string)
	    trace 1 "$model created pid=$pid"
	}
	"error: couldn't create process" {
	    error_msg create $model
	}
	timeout {
	    error_msg create $model
	}
	default {
	    error_msg create $model
	}
    }

    expect "\n> "
}

proc do_act {op pid act} {
    send "$op $pid $act\n"
    expect {
	"Error" {
	    error_msg $op $act
	} 
	"Performing" {
	    trace 2 "$op $act"
	} 
	timeout {
	    error_msg $op $act
	}
	default {
	    error_msg $op $act
	}
    }  

    expect "\n> "
}

proc do {pid act} { 
    return [do_act do $pid $act]
}

proc done {pid act} { 
    return [do_act done $pid $act]
}

proc act_state {pid act state} {
    send "actions\n"
    expect {
	-re "$pid\[ \]+$act.*($state)" {
	    trace 1 "${act} ${pid} found to be $state" 
	}

	"\n> " {
	    error_msg actions $act
	}

	timeout {
	    error_msg actions $act
	}
    }

    expect "\n> "
}

proc proc_done {pid model} {
    send "actions\n"
    expect {
	-re "\n\[ \]*${pid}\[ \]+\[A-Za-z0-9_\]+\[ \]+.*\n> " {
	    error_msg proc_done "not done"
	}

	-re "\n> " {
	    trace 1 "$model completed successfully."
	}

	timeout {
	    error_msg proc_done timeout
	}
    }
}


# defaults
set timeout 1
set verbosity 0
log_user 0
set shell "../shell"
set iterations 1

parse_args $argv $argc

puts -nonewline "$tc_name: "
flush stdout
read_tc $tc_name

if {$verbosity > 0} {
    puts stderr "model: $model"
    puts stderr "script: $script"
    puts stderr "iterations: $iterations"
}

# Reset process table.
set proc_table [open "proc_table.dat" "w"]
puts $proc_table ""
close $proc_table

if {$verbosity >= 3} {
    log_user 1
}
spawn ${shell}
expect {
    "> " {}
    timeout {
	error_msg shell-spawn timeout
    }
}

for {set i 0} {$i < $iterations} {incr i} {
    eval $script
}

send "quit\n"
expect "Exiting"
log_user 1
puts "done."
