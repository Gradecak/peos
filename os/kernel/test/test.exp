#!/usr/bin/expect -f
# Expect script to test kernel via shell.

proc error_msg {op act} {
  global expect_out
  puts "FAILURE: while performing '$op' on '$act': $expect_out(buffer)"
  exit
}

proc shell_expect {} {
  global tc_name
  expect {
    "Error" {
      error_msg
    } 
    "Performing" {
    } 
    default {
      error_msg
    }
    timeout {
      error_msg
    }
  }  
}

set tc_name [lindex $argv 0]

puts -nonewline "$tc_name: "
flush stdout


# Read test case definition.
set input [open $tc_name "r"]
set data [read $input]
set model [lindex $data 0]
set actions [lrange $data 1 end]
 

# Reset process table.
set proc_table [open "proc_table.dat" "w"]
puts $proc_table ""
close $proc_table

log_user 0
spawn ../shell
expect ">"

send "create $model\n"
expect {
  "Created pid" {}
  "error: couldn't create process" {
    error_msg
  }
}
expect ">"

foreach act $actions {
  # Look for act to be ready.
  send "actions\n"
  expect {
    -re "$act.*(ready)" {}
    ">" {
      error_msg actions $act
    }
  }

  # Perform act.
  send "do 0 $act\n"
  shell_expect
  expect ">"

  # Look for act to be active.
  send "actions\n"
  expect {
    -re "$act.*(active)" {}
    ">" {
      error_msg actions $act
    }
  }
  expect ">"

  # Finish act.
  send "done 0 $act\n"
  shell_expect
  expect ">"
}

send "quit\n"
expect Exiting
log_user 1
puts "done."
